<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Experience</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.137.5/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.137.5/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <button class="startButton" id="startButton1" disabled>Start Experience</button>
    <button id="resetButton" style="display: none;">Reset Experience</button>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';
        import { OculusHandPointerModel } from 'three/addons/webxr/OculusHandPointerModel.js';
        import { createText } from 'three/addons/webxr/Text2D.js';

        import { World, System, Component, TagComponent, Types } from 'three/addons/libs/ecsy.module.js';

        class Object3D extends Component { }

        Object3D.schema = {
            object: { type: Types.Ref }
        };

        class Button extends Component { }

        Button.schema = {
            currState: { type: Types.String, default: 'none' },
            prevState: { type: Types.String, default: 'none' },
            action: { type: Types.Ref, default: () => {} }
        };

        class ButtonSystem extends System {
            execute() {
                this.queries.buttons.results.forEach(entity => {
                    const button = entity.getMutableComponent(Button);
                    const buttonMesh = entity.getComponent(Object3D).object;
                    if (button.currState == 'none') {
                        buttonMesh.scale.set(1, 1, 1);
                    } else {
                        buttonMesh.scale.set(1.1, 1.1, 1.1);
                    }

                    if (button.currState == 'pressed' && button.prevState != 'pressed') {
                        button.action();
                    }

                    button.prevState = button.currState;
                    button.currState = 'none';
                });
            }
        }

        ButtonSystem.queries = {
            buttons: {
                components: [Button]
            }
        };

        class Intersectable extends TagComponent { }

        class HandRaySystem extends System {
            init(attributes) {
                this.handPointers = attributes.handPointers;
            }

            execute() {
                this.handPointers.forEach(hp => {
                    let distance = null;
                    let intersectingEntity = null;
                    this.queries.intersectable.results.forEach(entity => {
                        const object = entity.getComponent(Object3D).object;
                        const intersections = hp.intersectObject(object, false);
                        if (intersections && intersections.length > 0) {
                            if (distance == null || intersections[0].distance < distance) {
                                distance = intersections[0].distance;
                                intersectingEntity = entity;
                            }
                        }
                    });
                    if (distance) {
                        hp.setCursor(distance);
                        if (intersectingEntity.hasComponent(Button)) {
                            const button = intersectingEntity.getMutableComponent(Button);
                            if (hp.isPinched()) {
                                button.currState = 'pressed';
                            } else if (button.currState != 'pressed') {
                                button.currState = 'hovered';
                            }
                        }
                    } else {
                        hp.setCursor(1.5);
                    }
                });
            }
        }

        HandRaySystem.queries = {
            intersectable: {
                components: [Intersectable]
            }
        };

        const world = new World();
        const clock = new THREE.Clock();
        let camera, scene, renderer, mixer, court, video, videoTexture;
        const audioSources = [];
        let startButtonEnabled = false;

        init();
        animate();

        function makeButtonMesh(x, y, z, color) {
            const geometry = new THREE.BoxGeometry(x, y, z);
            const material = new THREE.MeshPhongMaterial({ color: color });
            const buttonMesh = new THREE.Mesh(geometry, material);
            buttonMesh.castShadow = true;
            buttonMesh.receiveShadow = true;
            return buttonMesh;
        }

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            renderer.xr.enabled = true;
            document.body.appendChild(ARButton.createButton(renderer));

            const controller1 = renderer.xr.getController(0);
            scene.add(controller1);
            const controller2 = renderer.xr.getController(1);
            scene.add(controller2);

            const controllerModelFactory = new XRControllerModelFactory();
            const hand1 = renderer.xr.getHand(0);
            hand1.add(new OculusHandModel(hand1));
            const handPointer1 = new OculusHandPointerModel(hand1, controller1);
            hand1.add(handPointer1);
            scene.add(hand1);

            const hand2 = renderer.xr.getHand(1);
            hand2.add(new OculusHandModel(hand2));
            const handPointer2 = new OculusHandPointerModel(hand2, controller2);
            hand2.add(handPointer2);
            scene.add(hand2);

            world.registerComponent(Object3D)
                .registerComponent(Button)
                .registerComponent(Intersectable);

            world.registerSystem(ButtonSystem)
                .registerSystem(HandRaySystem, { handPointers: [handPointer1, handPointer2] });

            const light = new THREE.DirectionalLight(0xffffff, 3);
            light.position.set(0, 6, 0);
            scene.add(light);

            const playButton = makeButtonMesh(0.2, 0.1, 0.01, 0x00ff00);
            playButton.position.set(0, 1, -1);
            scene.add(playButton);

            const pauseButton = makeButtonMesh(0.2, 0.1, 0.01, 0xffff00);
            pauseButton.position.set(0, 1.2, -1);
            scene.add(pauseButton);

            const restartButton = makeButtonMesh(0.2, 0.1, 0.01, 0xff0000);
            restartButton.position.set(0, 1.4, -1);
            scene.add(restartButton);

            const pbEntity = world.createEntity();
            pbEntity.addComponent(Intersectable);
            pbEntity.addComponent(Object3D, { object: playButton });
            const pbAction = function () {
                startExperience();
            };
            pbEntity.addComponent(Button, { action: pbAction });

            const paEntity = world.createEntity();
            paEntity.addComponent(Intersectable);
            paEntity.addComponent(Object3D, { object: pauseButton });
            const paAction = function () {
                pauseExperience();
            };
            paEntity.addComponent(Button, { action: paAction });

            const rbEntity = world.createEntity();
            rbEntity.addComponent(Intersectable);
            rbEntity.addComponent(Object3D, { object: restartButton });
            const rbAction = function () {
                restartExperience();
            };
            rbEntity.addComponent(Button, { action: rbAction });

            loadAssets();
        }

        function loadAssets() {
            const loader = new GLTFLoader();
            loader.load('https://uploads-ssl.webflow.com/62585c8f3b855d70abac2fff/66464fdbb596dafdc5a82406_rtvse-asd.glb.txt', function (gltf) {
                court = gltf.scene;
                court.scale.set(0.1, 0.1, 0.1); // Set the scale to 0.1 for AR
                scene.add(court);
                mixer = new THREE.AnimationMixer(court);
                gltf.animations.forEach((clip) => {
                    mixer.clipAction(clip).play();
                });

                video = document.createElement('video');
                video.src = 'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/NBA_AllStar_Demo_Clip%20(2).mp4';
                video.crossOrigin = "anonymous";
                video.preload = 'auto';
                video.load();
                video.muted = true;
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                videoTexture.format = THREE.RGBAFormat;

                const geometry = new THREE.PlaneGeometry(4, 2.25);
                const material = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide });
                const videoScreen = new THREE.Mesh(geometry, material);
                videoScreen.position.set(0, 2, -5);
                videoScreen.scale.set(-1, 1, 1);
                scene.add(videoScreen);

                const listener = new THREE.AudioListener();
                camera.add(listener);

                const audioUrls = [
                    'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Ball_Stem.mp3',
                    'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Player1_Stem.mp3',
                    'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Player2_Stem.mp3',
                    'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Player3_Stem.mp3',
                    'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Player4_Stem.mp3',
                    'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Player5_Stem.mp3',
                    'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Player6_Stem.mp3',
                    'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/NetL_Stem.mp3',
                    'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/NetR_Stem.mp3'
                ];
                const modelIDs = ['1', '2', '3', '4', '5', '6', '7', 'basket1', 'basket2'];
                const audioLoader = new THREE.AudioLoader();
                const nonSpatialAudioUrl = 'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/AllStar_Game_FOH.mp3';
                const nonSpatialAudio = new THREE.Audio(listener);
                const nonSpatialAudioLoader = new THREE.AudioLoader();
                nonSpatialAudioLoader.load(nonSpatialAudioUrl, (buffer) => {
                    nonSpatialAudio.setVolume(1);
                    listener.add(nonSpatialAudio);
                    audioSources.push(nonSpatialAudio);
                });

                court.traverse((child) => {
                    const index = modelIDs.indexOf(child.name);
                    if (index !== -1) {
                        audioLoader.load(audioUrls[index], (buffer) => {
                            const audio = new THREE.PositionalAudio(listener);
                            audio.setBuffer(buffer);
                            audio.setRefDistance(1);
                            audio.setDistanceModel('exponential');
                            audio.setRolloffFactor(2.5);
                            child.add(audio);
                            audioSources.push(audio);
                        }, undefined, function (error) {
                            console.error(`Error loading audio for model ${child.name}:`, error);
                        });
                    }
                });

                const ambientLight = new THREE.AmbientLight(0xffffff, 1);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(0, 20, 10);
                scene.add(directionalLight);
                const pointLight1 = new THREE.PointLight(0xFFA500, 0.4, 30);
                pointLight1.position.set(0, 10, -25);
                scene.add(pointLight1);
                const pointLight2 = new THREE.PointLight(0xFFA500, 0.4, 30);
                pointLight2.position.set(0, 10, 25);
                scene.add(pointLight2);
                const pointLight3 = new THREE.PointLight(0x0000FF, 0.4, 30);
                pointLight3.position.set(-10, 10, 0);
                scene.add(pointLight3);
                const pointLight4 = new THREE.PointLight(0x0000FF, 0.4, 30);
                pointLight4.position.set(10, 10, 0);
                scene.add(pointLight4);

                checkAllLoaded();
            });
        }

        function checkAllLoaded() {
            if (!startButtonEnabled) {
                startButtonEnabled = true;
                const startButton1 = document.getElementById('startButton1');
                if (startButton1) {
                    startButton1.disabled = false;
                }
            }
        }

        function animate() {
            renderer.setAnimationLoop(() => {
                const delta = clock.getDelta();
                if (mixer) {
                    mixer.update(delta);
                }
                renderer.render(scene, camera);
            });
        }

        function startExperience() {
            if (mixer) {
                mixer._actions.forEach(action => {
                    action.paused = false;
                    action.play();
                });
            }
            audioSources.forEach(audio => {
                if (!audio.isPlaying) {
                    audio.play();
                }
            });
            if (video && video.paused) {
                video.play();
            }
            document.getElementById('resetButton').style.display = 'block';
            document.querySelectorAll('.startButton').forEach(button => {
                button.style.display = 'none';
            });
        }

        function pauseExperience() {
            if (mixer) {
                mixer._actions.forEach(action => {
                    action.paused = true;
                });
            }
            audioSources.forEach(audio => audio.pause());
            if (video && !video.paused) {
                video.pause();
            }
        }

        function restartExperience() {
            stopExperience();
            startExperience();
        }

        function stopExperience() {
            if (mixer) {
                mixer.stopAllAction();
                mixer._actions.forEach(action => {
                    action.stop();
                    action.reset();
                });
            }
            audioSources.forEach(audio => audio.stop());
            if (video) {
                video.pause();
                video.currentTime = 0;
            }
        }

        document.getElementById('resetButton').addEventListener('click', restartExperience);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('startButton1').addEventListener('click', startExperience);
        document.addEventListener('visibilitychange', function () {
            if (document.hidden) {
                stopExperience();
            }
        });
    </script>
</body>
</html>
