<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Experience</title>
    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { XRButton } from 'three/addons/webxr/XRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        let isGLBLoaded = false;
        let isVideoLoaded = false;
        let allAudioLoaded = false;
        let audioLoadedCount = 0;
        let court;
        const intersected = [];
        const audioSources = [];
        const audioLoader = new THREE.AudioLoader();

        const video = document.createElement('video');
        video.crossOrigin = "anonymous";
        video.preload = 'auto';
        video.load();
        video.muted = true;

        const videoTexture = new THREE.VideoTexture(video);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.format = THREE.RGBAFormat;

        const videoGeometry = new THREE.PlaneGeometry(4, 2.25);
        const videoMaterial = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide });
        const videoScreen = new THREE.Mesh(videoGeometry, videoMaterial);

        videoScreen.position.set(0, .2, -.5);
        videoScreen.rotation.y = Math.PI;
        videoScreen.scale.set(-0.1, 0.1, 0.1);

        const scene = new THREE.Scene();
        scene.add(videoScreen);

        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const listener = new THREE.AudioListener();
        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer.xr.setReferenceSpaceType('local-floor');
        renderer.xr.enabled = true;
        document.body.appendChild(XRButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

        scene.background = null;

        const initialCameraPosition = new THREE.Vector3(0, 2, 6);
        const initialCameraRotation = new THREE.Euler(0, THREE.MathUtils.degToRad(0), 0);
        camera.position.copy(initialCameraPosition);
        camera.rotation.copy(initialCameraRotation);
        camera.updateProjectionMatrix();
        camera.add(listener);

        function preloadVideo(url) {
            const req = new XMLHttpRequest();
            req.open('GET', url, true);
            req.responseType = 'blob';
            req.onload = function () {
                if (this.status === 200) {
                    var videoBlob = this.response;
                    var vid = URL.createObjectURL(videoBlob);
                    video.src = vid;
                    console.log('Video preloaded!');
                }
            };
            req.onerror = function () {
                console.log('Error on preloading video.');
            };
            req.send();
        }

        preloadVideo('https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/NBA_AllStar_Demo_Clip%20(2).mp4');

        const audioUrls = [
            'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Ball_Stem.mp3',
            'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Player1_Stem.mp3',
            'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Player2_Stem.mp3',
            'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Player3_Stem.mp3',
            'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Player4_Stem.mp3',
            'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Player5_Stem.mp3',
            'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/Player6_Stem.mp3',
            'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/NetL_Stem.mp3',
            'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/NetR_Stem.mp3'
        ];

        const modelIDs = ['1', '2', '3', '4', '5', '6', '7', 'basket1', 'basket2'];

        const loader = new GLTFLoader();
        let mixer;
        const clock = new THREE.Clock();

        loader.load('https://uploads-ssl.webflow.com/62585c8f3b855d70abac2fff/66464fdbb596dafdc5a82406_rtvse-asd.glb.txt', function (gltf) {
            court = gltf.scene;
            court.scale.set(0.1, 0.1, 0.1);
            court.position.set(0, .5, -1); // Place court initially in front of the camera
            scene.add(court);

            mixer = new THREE.AnimationMixer(court);
            gltf.animations.forEach((clip) => {
                mixer.clipAction(clip).play();
            });

            court.traverse((child) => {
                const index = modelIDs.indexOf(child.name);
                if (index !== -1) {
                    audioLoader.load(audioUrls[index], (buffer) => {
                        const audio = new THREE.PositionalAudio(listener);
                        audio.setBuffer(buffer);
                        audio.setRefDistance(1);
                        audio.setDistanceModel('exponential');
                        audio.setRolloffFactor(2.5);
                        child.add(audio);
                        audioSources.push(audio);

                        audioLoadedCount++;
                        if (audioLoadedCount === audioUrls.length) {
                            allAudioLoaded = true;
                            checkAllLoaded();
                        }
                    }, undefined, function (error) {
                        console.error(`Error loading audio for model ${child.name}:`, error);
                    });
                }
            });

            isGLBLoaded = true;
            checkAllLoaded();
        }, undefined, function (error) {
            console.error('An error happened during the loading of the GLB:', error);
        });

        const nonSpatialAudioUrl = 'https://raw.githubusercontent.com/zpennachi/ESR-VSE_DEMO/main/AllStar_Game_FOH.mp3';
        const nonSpatialAudio = new THREE.Audio(listener);
        const nonSpatialAudioLoader = new THREE.AudioLoader();
        nonSpatialAudioLoader.load(nonSpatialAudioUrl, (buffer) => {
            nonSpatialAudio.setVolume(1);
            listener.add(nonSpatialAudio);
            audioSources.push(nonSpatialAudio);
        });

        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 20, 10);
        scene.add(directionalLight);
        const pointLight1 = new THREE.PointLight(0xFFA500, 0.4, 30);
        pointLight1.position.set(0, 10, -25);
        scene.add(pointLight1);
        const pointLight2 = new THREE.PointLight(0xFFA500, 0.4, 30);
        pointLight2.position.set(0, 10, 25);
        scene.add(pointLight2);
        const pointLight3 = new THREE.PointLight(0x0000FF, 0.4, 30);
        pointLight3.position.set(-10, 10, 0);
        scene.add(pointLight3);
        const pointLight4 = new THREE.PointLight(0x0000FF, 0.4, 30);
        pointLight4.position.set(10, 10, 0);
        scene.add(pointLight4);

        function checkAllLoaded() {
            console.log(`GLB Loaded: ${isGLBLoaded}, Video Loaded: ${isVideoLoaded}, All Audio Loaded: ${allAudioLoaded}`);
            if (isGLBLoaded && isVideoLoaded && allAudioLoaded) {
                createStartButton();
                createResetButton();
                console.log("All assets loaded. Ready to start!");
            }
        }

        video.addEventListener('canplaythrough', () => {
            isVideoLoaded = true;
            checkAllLoaded();
        });

        if (video.readyState >= 4) {
            isVideoLoaded = true;
            checkAllLoaded();
        }

        function createButton(color, onClick) {
            const buttonGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1); // Smaller size
            const buttonMaterial = new THREE.MeshBasicMaterial({ color });
            const buttonMesh = new THREE.Mesh(buttonGeometry, buttonMaterial);

            buttonMesh.userData.onClick = onClick;
            buttonMesh.userData.originalColor = color;

            return buttonMesh;
        }

        function createStartButton() {
            const startButton = createButton(0x00ff00, startExperience);
            startButton.position.set(0, 0.5, -.5); // In front of the user, on the floor
            scene.add(startButton);
        }

        function createResetButton() {
            const resetButton = createButton(0xff0000, () => {
                stopExperience();
                startExperience();
            });
            resetButton.position.set(0, 0.5, -.3); // In front of the user, on the floor
            scene.add(resetButton);
        }

        function animate() {
            renderer.setAnimationLoop(() => {
                const delta = clock.getDelta();
                if (mixer) {
                    mixer.update(delta);
                }
                if (video && video.readyState >= video.HAVE_CURRENT_DATA) {
                    videoTexture.needsUpdate = true;
                }
                renderer.render(scene, camera);
            });
        }

        function onSessionStarted(session) {
            session.requestReferenceSpace('local-floor').then(function (referenceSpace) {
                renderer.xr.setReferenceSpaceType('local-floor');
                renderer.xr.setReferenceSpace(referenceSpace);
                session.requestAnimationFrame(onAnimationFrame);
            });
        }

        function onAnimationFrame(time, frame) {
            const referenceSpace = frame.session.refSpace;
            const viewerPose = frame.getViewerPose(referenceSpace);
            if (viewerPose) {
                const viewerPosition = viewerPose.transform.position;
                const viewerRotation = viewerPose.transform.orientation;
                const offset = new THREE.Vector3(0, 0, -1); // In front of the user
                offset.applyQuaternion(viewerRotation);
                const spawnPoint = viewerPosition.clone().add(offset);
                court.position.copy(spawnPoint);
                court.position.y = 0; // On the floor
            }
            renderer.render(scene, camera);
            frame.session.requestAnimationFrame(onAnimationFrame);
        }

        renderer.xr.addEventListener('sessionstart', onSessionStarted);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function stopExperience() {
            if (mixer) {
                mixer.stopAllAction();
                mixer._actions.forEach(action => {
                    action.stop();
                    action.reset();
                });
            }
            audioSources.forEach(audio => audio.stop());
            video.pause();
            video.currentTime = 0;
        }

        let experienceTimer;
        const totalDuration = 120;

        function startExperience() {
            clearTimeout(experienceTimer);
            experienceTimer = setTimeout(stopExperience, totalDuration * 1000);

            if (mixer) {
                mixer.stopAllAction();
                mixer.update(0);
                mixer._actions.forEach(action => {
                    action.reset();
                    action.play();
                });
            }

            audioSources.forEach(audio => {
                if (!audio.isPlaying) {
                    audio.play();
                }
            });

            video.play();
            animate();
        }

        function intersectObjects(controller) {
            const raycaster = new THREE.Raycaster();
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                if (intersect.object.userData.onClick) {
                    intersect.object.material.emissive.set(0x0000ff); // Hover color
                    intersect.object.userData.onClick();
                }
            }
        }

        function handleController(controller) {
            intersectObjects(controller);
        }

        function cleanIntersected() {
            while (intersected.length) {
                const object = intersected.pop();
                if (object.material && object.material.emissive) {
                    object.material.emissive.set(object.userData.originalColor); // Restore original color
                }
            }
        }

        renderer.setAnimationLoop(() => {
            cleanIntersected();
            handleController(renderer.xr.getController(0));
            handleController(renderer.xr.getController(1));
            renderer.render(scene, camera);
        });

        const controllerModelFactory = new XRControllerModelFactory();
        const controller1 = renderer.xr.getController(0);
        scene.add(controller1);

        const controller2 = renderer.xr.getController(1);
        scene.add(controller2);

        const controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);

        const controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        scene.add(controllerGrip2);

        window.addEventListener('resize', onWindowResize, false);
    </script>
</body>
</html>
